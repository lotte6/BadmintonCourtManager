<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton Match Management System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 75vw;
            width: 75%;
            margin: 0 auto;
            margin-right: 450px; /* Leave space for floating log */
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 20px;
        }

        .left-column {
            width: 100%;
        }

        .floating-match-log {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: 20px;
            width: 400px;
            height: calc(100vh - 40px);
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border-left: 5px solid #4facfe;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1000;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .floating-match-log.minimized {
            height: 60px;
            overflow: hidden;
        }

        .floating-match-log.dragging {
            transition: none;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
            cursor: move;
            user-select: none;
        }

        .log-controls {
            display: flex;
            gap: 5px;
        }

        .log-control-btn {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .log-control-btn:hover {
            background: rgba(0,0,0,0.1);
        }

        .log-content {
            height: calc(100vh - 140px);
            overflow-y: auto;
            padding-right: 5px;
        }

        .floating-match-log.minimized .log-content {
            display: none;
        }

        @media (max-width: 1600px) {
            .container {
                max-width: 70vw;
                width: 70%;
                margin-right: 450px;
            }
        }

        @media (max-width: 1400px) {
            .container {
                max-width: 65vw;
                width: 65%;
                margin-right: 420px;
            }

            .floating-match-log {
                width: 380px;
            }
        }

        @media (max-width: 1200px) {
            .container {
                max-width: 95vw;
                width: 95%;
                margin-right: auto;
            }

            .floating-match-log {
                position: relative;
                top: auto;
                right: auto;
                width: 100%;
                max-height: 400px;
                margin-top: 20px;
            }

            .log-header {
                cursor: default;
            }
        }

        .section {
            margin-bottom: 40px;
            padding: 25px;
            border-radius: 10px;
            background: #f8f9fa;
            border-left: 5px solid #4facfe;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #4facfe;
        }

        .btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
        }

        .btn-danger:hover {
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        }

        .btn-success:hover {
            box-shadow: 0 5px 15px rgba(81, 207, 102, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffd43b 0%, #fab005 100%);
            color: #333;
        }

        .btn-warning:hover {
            box-shadow: 0 5px 15px rgba(255, 212, 59, 0.4);
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .player-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 2px solid #e9ecef;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .player-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .player-card.unavailable {
            border-color: #ff6b6b;
            background: #fff5f5;
        }

        .player-info {
            margin-bottom: 15px;
        }

        .player-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
            width: 100%;
        }

        .player-id {
            background: #e9ecef;
            color: #495057;
            font-size: 0.75em;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: normal;
            min-width: 30px;
            text-align: center;
        }

        .player-stats {
            color: #666;
            font-size: 0.9em;
        }

        .player-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-top: 10px;
        }

        .status-available {
            background: #d4edda;
            color: #155724;
        }

        .status-unavailable {
            background: #f8d7da;
            color: #721c24;
        }

        .match-result {
            background: #e7f3ff;
            border: 2px solid #4facfe;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .match-players {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .match-player {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stats-table th,
        .stats-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .stats-table th {
            background: #4facfe;
            color: white;
            font-weight: bold;
        }

        .stats-table tr:hover {
            background: #f8f9fa;
        }

        /* Compact table for right column */
        .right-column .stats-table th,
        .right-column .stats-table td {
            padding: 8px;
            font-size: 0.85em;
        }

        .right-column .stats-table th {
            font-size: 0.8em;
        }

        .rank {
            font-weight: bold;
            color: #4facfe;
        }

        .hidden {
            display: none !important;
        }

        .court-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 2px solid #e9ecef;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            text-align: center;
            position: relative;
            cursor: pointer;
        }

        .court-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .court-card.occupied {
            border-color: #ff6b6b;
            background: #fff5f5;
        }

        .court-card.available {
            border-color: #51cf66;
            background: #f8fff9;
        }

        .court-card.selected {
            border-color: #4facfe;
            background: #e7f3ff;
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.3);
        }

        .court-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .court-delete-btn:hover {
            background: #ee5a52;
        }

        .court-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .court-status {
            display: inline-block;
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .court-available {
            background: #d4edda;
            color: #155724;
        }

        .court-occupied {
            background: #f8d7da;
            color: #721c24;
        }

        .match-info {
            font-size: 0.9em;
            color: #666;
            line-height: 1.4;
        }

        .active-match {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .active-match h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .match-players-inline {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .match-player-inline {
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .player-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #333;
        }

        .player-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 6px;
            margin-bottom: 20px;
        }

        .player-selection-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 1em;
        }

        .player-selection-item:hover {
            border-color: #4facfe;
            background: #e7f3ff;
        }

        .player-selection-item.selected {
            border-color: #4facfe;
            background: #4facfe;
            color: white;
        }

        .player-selection-item.unavailable {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            cursor: pointer;
        }

        .player-selection-item.unavailable.selected {
            background: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .selected-players {
            background: #e7f3ff;
            border: 2px solid #4facfe;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .selected-players h4 {
            margin-bottom: 10px;
            color: #4facfe;
        }

        .selected-player-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .selected-player-tag {
            background: #4facfe;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .players-list {
            display: block !important;
        }

        .player-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid #e9ecef;
            transition: all 0.2s;
        }

        .player-list-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .player-list-item.unavailable {
            border-color: #ff6b6b;
            background: #fff5f5;
        }

        .player-list-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .player-list-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .player-list-actions .btn {
            padding: 6px 12px;
            font-size: 0.8em;
            margin: 0;
        }

        .queue-item {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 2px solid #e9ecef;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .queue-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        .queue-players {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .queue-player-tag {
            background: #4facfe;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .queue-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .court-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .court-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .court-selection-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .court-selection-item:hover {
            border-color: #4facfe;
            background: #e7f3ff;
        }

        .court-selection-item.occupied {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            cursor: not-allowed;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .main-content {
                padding: 20px;
            }

            .players-grid {
                grid-template-columns: 1fr;
            }

            .match-players {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè∏ Badminton Match Management System</h1>
            <p>Easily manage players and organize fair matches</p>
        </div>

        <div class="main-content">
            <!-- Message Display -->
            <div id="message" class="hidden"></div>

            <!-- Main Content -->
            <div class="left-column">

            <!-- Settings Section -->
            <div class="section">
                <h2>‚öôÔ∏è Settings</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div class="form-group">
                        <label for="matchCost">Match Cost per Player (Pesos)</label>
                        <input type="number" id="matchCost" value="30" min="0" max="1000">
                    </div>
                    <div class="form-group">
                        <label for="baseCost">Base Court Cost (Pesos)</label>
                        <input type="number" id="baseCost" value="140" min="0" max="10000">
                    </div>
                </div>
                <div style="text-align: center; display: flex; gap: 15px; justify-content: center;">
                    <button class="btn btn-success" onclick="confirmSettings()">‚úÖ Confirm Settings</button>
                    <button class="btn btn-danger" onclick="resetAll()">üîÑ Reset All</button>
                </div>
            </div>

            <!-- Match Queue Management -->
            <div class="section">
                <h2>üìã Match Queue</h2>
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px;">
                    <button class="btn" onclick="addToQueue()">‚ûï Add Match to Queue</button>
                    <button class="btn btn-warning" onclick="clearQueue()">üóëÔ∏è Clear Queue</button>
                </div>
                <div id="queueContainer">
                    <!-- Queue will be displayed here -->
                </div>
            </div>

            <!-- Court Management (moved to top - requirement 22) -->
            <div class="section">
                <h2>üèüÔ∏è Court Management</h2>
                <div style="display: flex; gap: 10px; align-items: end; margin-bottom: 20px;">
                    <div class="form-group" style="flex: 1; margin-bottom: 0;">
                        <label for="courtNumber">Court Number</label>
                        <input type="number" id="courtNumber" placeholder="Enter court number (numbers only)" min="1" max="999">
                    </div>
                    <button class="btn" onclick="addCustomCourt()">‚ûï Add Court</button>
                </div>

                <div id="courtsContainer" class="players-grid" style="margin-top: 20px;">
                    <!-- Court status will be displayed here -->
                </div>
            </div>

            <!-- Player Management -->
            <div class="section">
                <h2>üë• Player Management</h2>
                <div style="display: flex; gap: 10px; align-items: end; margin-bottom: 20px;">
                    <div class="form-group" style="flex: 1; margin-bottom: 0;">
                        <label for="playerName">Player Name</label>
                        <input type="text" id="playerName" placeholder="Enter player name">
                    </div>
                    <button class="btn" onclick="addPlayer()">‚ûï Add</button>
                    <button class="btn btn-warning" onclick="resetPlayers()">üîÑ Reset All</button>
                </div>

                <!-- Player Search and Controls -->
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                    <div class="form-group" style="flex: 1; margin-bottom: 0;">
                        <input type="text" id="playerSearch" placeholder="üîç Search player name..." onkeyup="searchPlayers()">
                    </div>
                    <button class="btn" onclick="togglePlayerView()" id="viewToggleBtn">üî≤ Switch to Card View</button>
                </div>

                <!-- Player Statistics -->
                <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 0.9em;">
                    <span>Total Players: <strong id="totalPlayers">0</strong></span> |
                    <span>Available: <strong id="availablePlayers">0</strong></span> |
                    <span>Unavailable: <strong id="unavailablePlayers">0</strong></span>
                </div>

                <div id="playersContainer" class="players-list">
                    <!-- Player cards will be dynamically generated here -->
                </div>

                <!-- Pagination Controls -->
                <div id="playerPagination" style="text-align: center; margin-top: 20px; display: none;">
                    <button class="btn" onclick="changePage(-1)" id="prevPageBtn">‚¨ÖÔ∏è Previous</button>
                    <span style="margin: 0 15px; font-weight: bold;" id="pageInfo">Page 1 of 1</span>
                    <button class="btn" onclick="changePage(1)" id="nextPageBtn">‚û°Ô∏è Next</button>
                </div>
            </div>

            </div>

        </div>

        <!-- Floating Match Log -->
        <div id="floatingMatchLog" class="floating-match-log">
            <div class="log-header" id="logHeader">
                <h3 style="margin: 0; color: #333; font-size: 1.1em;">üìã Match Log</h3>
                <div class="log-controls">
                    <button class="log-control-btn" onclick="clearMatchLog()" title="Clear Log">üóëÔ∏è</button>
                    <button class="log-control-btn" onclick="toggleMatchLog()" title="Minimize/Maximize" id="toggleBtn">‚ûñ</button>
                    <button class="log-control-btn" onclick="closeMatchLog()" title="Close">‚úñÔ∏è</button>
                </div>
            </div>
            <div class="log-content" id="matchLogContainer">
                <!-- Match log will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Player Selection Modal -->
    <div id="playerSelectionModal" class="player-selection-modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Edit Queue Match</h3>
                <button class="modal-close" onclick="closePlayerSelectionModal()">√ó</button>
            </div>

            <div class="selected-players">
                <h4>Selected Players (<span id="selectedCount">0</span>/4)</h4>
                <div id="selectedPlayersList" class="selected-player-list">
                    <!-- Selected players will be displayed here -->
                </div>
            </div>

            <div class="player-selection-grid" id="playerSelectionGrid">
                <!-- Available players will be displayed here -->
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" onclick="randomSelectPlayers()" style="margin-bottom: 10px;">üé≤ Random Select 4 Players</button>
                <button class="btn btn-warning" onclick="clearSelectedPlayers()" style="margin-bottom: 10px;">üóëÔ∏è Clear Selection</button>
                <br>
                <button class="btn btn-success" onclick="saveQueueEdit()" id="saveQueueBtn" disabled>üíæ Save Changes</button>
                <button class="btn" onclick="closePlayerSelectionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Court Selection Modal -->
    <div id="courtSelectionModal" class="court-selection-modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Select Court for Match</h3>
                <button class="modal-close" onclick="closeCourtSelectionModal()">√ó</button>
            </div>

            <div style="margin-bottom: 20px; padding: 15px; background: #e7f3ff; border-radius: 8px;">
                <h4 style="margin-bottom: 10px;">Match Players:</h4>
                <div id="assigningPlayersList" class="selected-player-list">
                    <!-- Players being assigned will be displayed here -->
                </div>
            </div>

            <div class="court-selection-grid" id="courtSelectionGrid">
                <!-- Available courts will be displayed here -->
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" onclick="closeCourtSelectionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let players = [];
        let nextPlayerId = 1;
        let courts = [];
        let activeMatches = [];
        let nextMatchId = 1;
        let nextCourtId = 1;
        let selectedCourt = null;
        let selectedPlayers = [];
        let matchLog = [];
        let matchQueue = [];
        let nextQueueId = 1;
        let editingQueueId = null; // Track which queue item is being edited
        let assigningQueueId = null; // Track which queue item is being assigned to court
        let settings = {
            matchCost: 30,
            baseCost: 140
        };

        // Floating log variables
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let isLogMinimized = false;
        let isLogVisible = true;

        // Player management related variables
        let currentPage = 1;
        let playersPerPage = 12;
        let isListView = true; // Default to list view (requirement 23)
        let searchTerm = '';
        let filteredPlayers = [];

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure modal is hidden
            const modal = document.getElementById('playerSelectionModal');
            if (modal) {
                modal.classList.add('hidden');
            }

            loadSettings();
            loadPlayers();
            loadCourts();
            loadActiveMatches();
            loadMatchLog();
            loadQueue();
            renderCourts();
            renderQueue();

            // Initialize floating log drag functionality
            initializeFloatingLog();
        });

        // Initialize floating log functionality
        function initializeFloatingLog() {
            const floatingLog = document.getElementById('floatingMatchLog');
            const logHeader = document.getElementById('logHeader');

            // Mouse events for dragging
            logHeader.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);

            // Touch events for mobile
            logHeader.addEventListener('touchstart', startDrag);
            document.addEventListener('touchmove', drag);
            document.addEventListener('touchend', stopDrag);
        }

        // Start dragging
        function startDrag(e) {
            if (window.innerWidth <= 1200) return; // Disable drag on mobile

            isDragging = true;
            const floatingLog = document.getElementById('floatingMatchLog');
            floatingLog.classList.add('dragging');

            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const rect = floatingLog.getBoundingClientRect();

            dragOffset.x = clientX - rect.left;
            dragOffset.y = clientY - rect.top;

            e.preventDefault();
        }

        // Drag the element
        function drag(e) {
            if (!isDragging) return;

            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const floatingLog = document.getElementById('floatingMatchLog');

            const newX = clientX - dragOffset.x;
            const newY = clientY - dragOffset.y;

            // Calculate available space (considering main content area)
            const container = document.querySelector('.container');
            const containerRect = container.getBoundingClientRect();
            const rightBoundary = containerRect.right + 20; // 20px gap from main content

            // Keep within viewport bounds, but respect main content area
            const minX = Math.max(0, rightBoundary);
            const maxX = window.innerWidth - floatingLog.offsetWidth;
            const maxY = window.innerHeight - floatingLog.offsetHeight;

            const boundedX = Math.max(minX, Math.min(newX, maxX));
            const boundedY = Math.max(0, Math.min(newY, maxY));

            floatingLog.style.left = boundedX + 'px';
            floatingLog.style.top = boundedY + 'px';
            floatingLog.style.right = 'auto'; // Remove right positioning

            e.preventDefault();
        }

        // Stop dragging
        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                const floatingLog = document.getElementById('floatingMatchLog');
                floatingLog.classList.remove('dragging');
            }
        }

        // Toggle minimize/maximize
        function toggleMatchLog() {
            const floatingLog = document.getElementById('floatingMatchLog');
            const toggleBtn = document.getElementById('toggleBtn');

            isLogMinimized = !isLogMinimized;

            if (isLogMinimized) {
                floatingLog.classList.add('minimized');
                toggleBtn.textContent = '‚ûï';
                toggleBtn.title = 'Maximize';
            } else {
                floatingLog.classList.remove('minimized');
                toggleBtn.textContent = '‚ûñ';
                toggleBtn.title = 'Minimize';
            }
        }

        // Close match log
        function closeMatchLog() {
            const floatingLog = document.getElementById('floatingMatchLog');
            floatingLog.style.display = 'none';
            isLogVisible = false;
        }

        // Show match log (can be called from menu or button)
        function showMatchLog() {
            const floatingLog = document.getElementById('floatingMatchLog');
            floatingLog.style.display = 'block';
            isLogVisible = true;
        }

        // Show message
        function showMessage(message, type = 'success') {
            const messageDiv = document.getElementById('message');
            messageDiv.className = type === 'success' ? 'alert alert-success' : 'alert alert-error';
            messageDiv.textContent = message;
            messageDiv.classList.remove('hidden');

            setTimeout(() => {
                messageDiv.classList.add('hidden');
            }, 3000);
        }

        // Load player data from local storage
        function loadPlayers() {
            const savedPlayers = localStorage.getItem('badmintonPlayers');
            if (savedPlayers) {
                players = JSON.parse(savedPlayers);
                // Ensure nextPlayerId is correct
                if (players.length > 0) {
                    nextPlayerId = Math.max(...players.map(p => p.id)) + 1;
                }
                // Ensure all players have cost property (for backward compatibility)
                players.forEach(player => {
                    if (!player.hasOwnProperty('cost')) {
                        player.cost = settings.baseCost; // Use settings base cost
                    }
                });
            }
            renderPlayers();
        }

        // Save player data to local storage
        function savePlayers() {
            localStorage.setItem('badmintonPlayers', JSON.stringify(players));
        }

        // Load settings
        function loadSettings() {
            const savedSettings = localStorage.getItem('badmintonSettings');
            if (savedSettings) {
                settings = JSON.parse(savedSettings);
            }
            // Update UI
            document.getElementById('matchCost').value = settings.matchCost;
            document.getElementById('baseCost').value = settings.baseCost;
        }

        // Save settings
        function saveSettings() {
            localStorage.setItem('badmintonSettings', JSON.stringify(settings));
        }

        // Add match to queue
        function addToQueue() {
            const totalPlayers = players.length;

            if (totalPlayers === 0) {
                alert('No players found! Please add players first before creating matches.');
                return;
            }

            if (totalPlayers < 4) {
                alert(`Cannot create match - insufficient total players!\n\nTotal players: ${totalPlayers}\nRequired: 4 players\n\nPlease add more players.`);
                return;
            }

            // Set up for creating new queue item
            editingQueueId = 'new';
            selectedPlayers = [];

            // Auto randomly select 4 available players by default (if possible)
            const availablePlayers = players.filter(player => player.is_available);
            if (availablePlayers.length >= 4) {
                const shuffled = [...availablePlayers].sort(() => 0.5 - Math.random());
                selectedPlayers = shuffled.slice(0, 4);
            }

            openPlayerSelectionModal();
        }

        // Save new queue item
        function saveNewQueueItem() {
            if (selectedPlayers.length !== 4) {
                showMessage(`Must select exactly 4 players. Currently selected: ${selectedPlayers.length}`, 'error');
                return;
            }

            // Check if any selected players no longer exist
            const missingPlayers = selectedPlayers.filter(selectedPlayer => {
                const currentPlayer = players.find(p => p.id === selectedPlayer.id);
                return !currentPlayer;
            });

            if (missingPlayers.length > 0) {
                showMessage(`Some selected players no longer exist: ${missingPlayers.map(p => p.name).join(', ')}`, 'error');
                return;
            }

            // Allow saving with unavailable players, but show warning
            const unavailablePlayers = selectedPlayers.filter(selectedPlayer => {
                const currentPlayer = players.find(p => p.id === selectedPlayer.id);
                return currentPlayer && !currentPlayer.is_available;
            });

            const queueItem = {
                id: nextQueueId++,
                players: selectedPlayers.map(p => ({...p})),
                createdTime: new Date().toLocaleString()
            };

            matchQueue.push(queueItem);
            saveQueue();
            renderQueue();

            let message = `Match added to queue with players: ${selectedPlayers.map(p => p.name).join(', ')}`;
            if (unavailablePlayers.length > 0) {
                message += `\n\nNote: ${unavailablePlayers.length} player(s) are currently unavailable and cannot be assigned to courts until they become available.`;
            }

            showMessage(message);
            closePlayerSelectionModal();
        }

        // Clear queue
        function clearQueue() {
            if (!confirm('Are you sure you want to clear the entire queue?')) {
                return;
            }
            matchQueue = [];
            saveQueue();
            renderQueue();
            showMessage('Queue cleared');
        }

        // Remove item from queue
        function removeFromQueue(queueId) {
            const queueIndex = matchQueue.findIndex(item => item.id === queueId);
            if (queueIndex !== -1) {
                matchQueue.splice(queueIndex, 1);
                saveQueue();
                renderQueue();
                showMessage('Match removed from queue');
            }
        }

        // Edit queue match
        function editQueueMatch(queueId) {
            const queueItem = matchQueue.find(item => item.id === queueId);
            if (!queueItem) {
                showMessage('Queue item not found', 'error');
                return;
            }

            editingQueueId = queueId;
            selectedPlayers = [...queueItem.players]; // Copy the current players
            openPlayerSelectionModal();
        }

        // Save queue edit
        function saveQueueEdit() {
            if (!editingQueueId) {
                showMessage('No queue item being edited', 'error');
                return;
            }

            if (editingQueueId === 'new') {
                // Creating new queue item
                saveNewQueueItem();
                return;
            }

            if (selectedPlayers.length !== 4) {
                showMessage(`Must select exactly 4 players. Currently selected: ${selectedPlayers.length}`, 'error');
                return;
            }

            // Check if all selected players are still available
            const unavailablePlayers = selectedPlayers.filter(selectedPlayer => {
                const currentPlayer = players.find(p => p.id === selectedPlayer.id);
                return !currentPlayer || !currentPlayer.is_available;
            });

            if (unavailablePlayers.length > 0) {
                showMessage(`Some selected players are no longer available: ${unavailablePlayers.map(p => p.name).join(', ')}`, 'error');
                return;
            }

            // Update the existing queue item
            const queueIndex = matchQueue.findIndex(item => item.id === editingQueueId);
            if (queueIndex !== -1) {
                matchQueue[queueIndex].players = selectedPlayers.map(p => ({...p}));
                saveQueue();
                renderQueue();
                showMessage('Queue match updated successfully');
                closePlayerSelectionModal();
            } else {
                showMessage('Queue item not found', 'error');
            }
        }

        // Render queue
        function renderQueue() {
            const container = document.getElementById('queueContainer');

            if (matchQueue.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; font-size: 1.1em;">No matches in queue. Click "Add Match to Queue" to add matches.</p>';
                return;
            }

            container.innerHTML = matchQueue.map(item => `
                <div class="queue-item">
                    <div class="queue-header">
                        <h4>Queue #${item.id}</h4>
                        <span style="color: #666; font-size: 0.9em;">${item.createdTime}</span>
                    </div>
                    <div class="queue-players">
                        ${item.players.map(player => `
                            <span class="queue-player-tag">${player.name}</span>
                        `).join('')}
                    </div>
                    <div class="queue-actions">
                        <button class="btn" onclick="editQueueMatch(${item.id})">‚úèÔ∏è Edit Players</button>
                        <button class="btn btn-success" onclick="assignToCourtFromQueue(${item.id})">üéØ Assign to Court</button>
                        <button class="btn btn-danger" onclick="removeFromQueue(${item.id})">üóëÔ∏è Remove</button>
                    </div>
                </div>
            `).join('');
        }

        // Assign queue item to court
        function assignToCourtFromQueue(queueId) {
            const queueItem = matchQueue.find(item => item.id === queueId);
            if (!queueItem) {
                showMessage('Queue item not found', 'error');
                return;
            }

            // Check if all players are still available
            const unavailablePlayers = queueItem.players.filter(queuePlayer => {
                const currentPlayer = players.find(p => p.id === queuePlayer.id);
                return !currentPlayer || !currentPlayer.is_available;
            });

            if (unavailablePlayers.length > 0) {
                let message = `Cannot assign match - some players are currently unavailable!\n\n`;
                message += `Unavailable players:\n`;
                unavailablePlayers.forEach(player => {
                    message += `‚Ä¢ ${player.name} (currently in a match)\n`;
                });
                message += `\nPlease wait for their matches to end or edit the queue to select different players.`;

                alert(message);
                return;
            }

            // Find available courts
            const availableCourts = courts.filter(court => !court.isOccupied);
            if (availableCourts.length === 0) {
                alert('No available courts!\n\nAll courts are currently occupied. Please wait for a match to end before assigning this queue item.');
                return;
            }

            // Open court selection modal
            assigningQueueId = queueId;
            openCourtSelectionModal();
        }

        // Open court selection modal
        function openCourtSelectionModal() {
            const queueItem = matchQueue.find(item => item.id === assigningQueueId);
            if (!queueItem) return;

            const modal = document.getElementById('courtSelectionModal');
            modal.classList.remove('hidden');

            // Display the players being assigned
            const playersList = document.getElementById('assigningPlayersList');
            playersList.innerHTML = queueItem.players.map(player =>
                `<span class="selected-player-tag">${player.name}</span>`
            ).join('');

            renderCourtSelection();
        }

        // Close court selection modal
        function closeCourtSelectionModal() {
            const modal = document.getElementById('courtSelectionModal');
            modal.classList.add('hidden');
            assigningQueueId = null;
        }

        // Render court selection
        function renderCourtSelection() {
            const container = document.getElementById('courtSelectionGrid');
            const availableCourts = courts.filter(court => !court.isOccupied);

            if (availableCourts.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; grid-column: 1/-1;">No available courts</p>';
                return;
            }

            // Sort courts by number
            const sortedCourts = [...availableCourts].sort((a, b) => {
                const aNum = parseInt(a.number);
                const bNum = parseInt(b.number);
                return aNum - bNum;
            });

            container.innerHTML = sortedCourts.map(court => `
                <div class="court-selection-item" onclick="selectCourtForAssignment(${court.id})">
                    <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 10px;">Court ${court.number}</div>
                    <div style="color: #28a745; font-weight: bold;">Available</div>
                </div>
            `).join('');
        }

        // Select court for assignment
        function selectCourtForAssignment(courtId) {
            const court = courts.find(c => c.id === courtId);
            const queueItem = matchQueue.find(item => item.id === assigningQueueId);

            if (!court || !queueItem) {
                showMessage('Invalid selection', 'error');
                return;
            }

            selectedCourt = court;
            selectedPlayers = queueItem.players;

            // Start match directly
            startMatchFromQueue(assigningQueueId);
            closeCourtSelectionModal();
        }

        // Start match from queue
        function startMatchFromQueue(queueId) {
            if (!selectedCourt || selectedPlayers.length !== 4) {
                showMessage('Invalid match setup', 'error');
                return;
            }

            // Create new match
            const newMatch = {
                id: nextMatchId++,
                courtId: selectedCourt.id,
                players: selectedPlayers.map(p => ({...p})),
                startTime: new Date().toLocaleString()
            };

            // Update court status
            selectedCourt.isOccupied = true;
            selectedCourt.matchId = newMatch.id;

            // Update selected players' status
            selectedPlayers.forEach(selectedPlayer => {
                const playerIndex = players.findIndex(player => player.id === selectedPlayer.id);
                if (playerIndex !== -1) {
                    players[playerIndex].is_available = false; // Unavailable during match
                }
            });

            activeMatches.push(newMatch);

            // Remove from queue
            const queueIndex = matchQueue.findIndex(item => item.id === queueId);
            if (queueIndex !== -1) {
                matchQueue.splice(queueIndex, 1);
            }

            savePlayers();
            saveCourts();
            saveActiveMatches();
            saveQueue();

            showMessage(`Match started! Playing on Court ${selectedCourt.number}`);

            selectedCourt = null;
            selectedPlayers = [];
            renderPlayers();
            renderCourts();
            renderQueue();
        }

        // Reset all data except players
        function resetAll() {
            const confirmMessage = `Are you sure you want to reset all data?\n\nThis will:\n‚Ä¢ Clear all active matches\n‚Ä¢ Clear match queue\n‚Ä¢ Clear match log\n‚Ä¢ Release all courts\n‚Ä¢ Set all players as available\n‚Ä¢ Reset player match counts\n\nPlayers will NOT be deleted.`;

            if (!confirm(confirmMessage)) {
                return;
            }

            // Clear active matches
            activeMatches = [];
            saveActiveMatches();

            // Clear match queue
            matchQueue = [];
            saveQueue();

            // Clear match log
            matchLog = [];
            saveMatchLog();

            // Release all courts
            courts.forEach(court => {
                court.isOccupied = false;
                court.matchId = null;
            });
            saveCourts();

            // Reset all players to available and reset match counts
            players.forEach(player => {
                player.is_available = true;
                player.match_count = 0;
                player.cost = settings.baseCost;
            });
            savePlayers();

            // Reset modal states
            selectedCourt = null;
            selectedPlayers = [];
            editingQueueId = null;
            assigningQueueId = null;

            // Refresh all displays
            renderPlayers();
            renderCourts();
            renderQueue();
            renderMatchLog();

            showMessage('All data has been reset successfully! Players have been preserved.');
        }

        // Confirm settings
        function confirmSettings() {
            const matchCost = parseInt(document.getElementById('matchCost').value);
            const baseCost = parseInt(document.getElementById('baseCost').value);

            // Validate match cost
            if (isNaN(matchCost) || matchCost < 0) {
                showMessage('Match cost must be a valid number (0 or greater)', 'error');
                document.getElementById('matchCost').value = settings.matchCost;
                return;
            }

            // Validate base cost
            if (isNaN(baseCost) || baseCost < 0) {
                showMessage('Base cost must be a valid number (0 or greater)', 'error');
                document.getElementById('baseCost').value = settings.baseCost;
                return;
            }

            // Update settings
            settings.matchCost = matchCost;
            settings.baseCost = baseCost;
            saveSettings();

            // Update all players' base cost to new setting
            players.forEach(player => {
                player.cost = settings.baseCost;
            });
            savePlayers();

            // Refresh all displays that show costs
            renderPlayers(); // Update player display with new costs
            renderQueue(); // Update queue display with new costs
            showMessage(`Settings updated: Match cost ‚Ç±${matchCost}, Base cost ‚Ç±${baseCost}. All player costs refreshed.`);
        }

        // Load court data
        function loadCourts() {
            const savedCourts = localStorage.getItem('badmintonCourts');
            const savedNextCourtId = localStorage.getItem('badmintonNextCourtId');

            if (savedNextCourtId) {
                nextCourtId = parseInt(savedNextCourtId);
            }

            if (savedCourts) {
                courts = JSON.parse(savedCourts);
                // Ensure nextCourtId is correct
                if (courts.length > 0) {
                    nextCourtId = Math.max(...courts.map(c => c.id)) + 1;
                }
            }
        }

        // Initialize courts (removed, only use custom courts)

        // Save court data
        function saveCourts() {
            localStorage.setItem('badmintonCourts', JSON.stringify(courts));
            localStorage.setItem('badmintonNextCourtId', nextCourtId.toString());
        }

        // Load active matches
        function loadActiveMatches() {
            const savedMatches = localStorage.getItem('badmintonActiveMatches');
            const savedNextMatchId = localStorage.getItem('badmintonNextMatchId');

            if (savedMatches) {
                activeMatches = JSON.parse(savedMatches);
            }

            if (savedNextMatchId) {
                nextMatchId = parseInt(savedNextMatchId);
            }
        }

        // Save active matches
        function saveActiveMatches() {
            localStorage.setItem('badmintonActiveMatches', JSON.stringify(activeMatches));
            localStorage.setItem('badmintonNextMatchId', nextMatchId.toString());
        }

        // Load queue
        function loadQueue() {
            const savedQueue = localStorage.getItem('badmintonMatchQueue');
            const savedNextQueueId = localStorage.getItem('badmintonNextQueueId');

            if (savedQueue) {
                matchQueue = JSON.parse(savedQueue);
            }

            if (savedNextQueueId) {
                nextQueueId = parseInt(savedNextQueueId);
            }
        }

        // Save queue
        function saveQueue() {
            localStorage.setItem('badmintonMatchQueue', JSON.stringify(matchQueue));
            localStorage.setItem('badmintonNextQueueId', nextQueueId.toString());
        }

        // Render player list
        function renderPlayers() {
            const container = document.getElementById('playersContainer');

            // Update statistics
            updatePlayerStats();

            // Apply search filter
            filteredPlayers = players.filter(player =>
                player.name.toLowerCase().includes(searchTerm.toLowerCase())
            );

            if (filteredPlayers.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; font-size: 1.1em;">No players found. Please add players first.</p>';
                document.getElementById('playerPagination').style.display = 'none';
                return;
            }

            // Calculate pagination
            const totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
            const startIndex = (currentPage - 1) * playersPerPage;
            const endIndex = startIndex + playersPerPage;
            const currentPlayers = filteredPlayers.slice(startIndex, endIndex);

            // Set container style
            container.className = isListView ? 'players-list' : 'players-grid';

            if (isListView) {
                // List view
                container.innerHTML = currentPlayers.map(player => {
                    const cost = (player.cost || settings.baseCost) + (player.match_count * settings.matchCost); // Base cost + match cost per match
                    return `
                    <div class="player-list-item ${!player.is_available ? 'unavailable' : ''}">
                        <div class="player-list-info">
                            <span class="player-id">${player.id}</span>
                            <span style="font-weight: bold;">${player.name}</span>
                            <span style="color: #666;">Matches: ${player.match_count}</span>
                            <span class="player-status ${player.is_available ? 'status-available' : 'status-unavailable'}">
                                ${player.is_available ? 'Available' : 'Unavailable'}
                            </span>
                        </div>
                        <div class="player-list-actions">
                            <span style="color: #28a745; font-weight: bold; margin-right: 15px;">‚Ç±${cost}</span>
                            <button class="btn ${player.is_available ? 'btn-warning' : 'btn-success'}" onclick="togglePlayerStatus(${player.id})">
                                ${player.is_available ? 'üö´ Set Unavailable' : '‚úÖ Set Available'}
                            </button>
                            <button class="btn" onclick="editPlayer(${player.id}, '${player.name}')">‚úèÔ∏è Edit</button>
                            <button class="btn btn-danger" onclick="deletePlayer(${player.id})">üóëÔ∏è Delete</button>
                        </div>
                    </div>
                `;}).join('');
            } else {
                // Card view
                container.innerHTML = currentPlayers.map(player => {
                    const cost = (player.cost || settings.baseCost) + (player.match_count * settings.matchCost); // Base cost + match cost per match
                    return `
                    <div class="player-card ${!player.is_available ? 'unavailable' : ''}">
                        <div class="player-info">
                            <div class="player-name">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span class="player-id">${player.id}</span>
                                    <span>${player.name}</span>
                                </div>
                                <span style="color: #28a745; font-weight: bold;">‚Ç±${cost}</span>
                            </div>
                            <div class="player-stats">Matches: ${player.match_count}</div>
                            <span class="player-status ${player.is_available ? 'status-available' : 'status-unavailable'}">
                                ${player.is_available ? 'Available' : 'Unavailable'}
                            </span>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 10px;">
                            <button class="btn ${player.is_available ? 'btn-warning' : 'btn-success'}" onclick="togglePlayerStatus(${player.id})" style="font-size: 0.8em;">
                                ${player.is_available ? 'üö´ Unavailable' : '‚úÖ Available'}
                            </button>
                            <button class="btn" onclick="editPlayer(${player.id}, '${player.name}')">‚úèÔ∏è Edit</button>
                            <button class="btn btn-danger" onclick="deletePlayer(${player.id})">üóëÔ∏è Delete</button>
                        </div>
                    </div>
                `;}).join('');
            }

            // Update pagination controls
            updatePagination(totalPages);
        }

        // Add player
        function addPlayer() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim();

            if (!name) {
                showMessage('Please enter player name', 'error');
                return;
            }

            // Check if player with same name already exists
            if (players.some(player => player.name === name)) {
                showMessage('Player name already exists', 'error');
                return;
            }

            const newPlayer = {
                id: nextPlayerId++,
                name: name,
                match_count: 0,
                is_available: true,
                cost: settings.baseCost // Use settings base cost
            };

            players.push(newPlayer);
            savePlayers();
            showMessage(`Player ${name} added successfully`);
            nameInput.value = '';
            currentPage = 1; // Reset to first page
            renderPlayers();
        }

        // Edit player
        function editPlayer(playerId, currentName) {
            const newName = prompt('Please enter new player name:', currentName);
            if (newName && newName.trim() && newName.trim() !== currentName) {
                updatePlayer(playerId, newName.trim());
            }
        }

        // Update player
        function updatePlayer(playerId, newName) {
            // Check if player with same name already exists
            if (players.some(player => player.name === newName && player.id !== playerId)) {
                showMessage('Player name already exists', 'error');
                return;
            }

            const playerIndex = players.findIndex(player => player.id === playerId);
            if (playerIndex !== -1) {
                const oldName = players[playerIndex].name;
                players[playerIndex].name = newName;
                savePlayers();
                showMessage(`Player ${oldName} updated to ${newName}`);
                renderPlayers();
            }
        }

        // Delete player
        function deletePlayer(playerId) {
            if (!confirm('Are you sure you want to delete this player?')) {
                return;
            }

            const playerIndex = players.findIndex(player => player.id === playerId);
            if (playerIndex !== -1) {
                const playerName = players[playerIndex].name;
                players.splice(playerIndex, 1);
                savePlayers();
                showMessage(`Player ${playerName} deleted`);
                renderPlayers();
            }
        }

        // Toggle player status (requirement 25)
        function togglePlayerStatus(playerId) {
            const playerIndex = players.findIndex(player => player.id === playerId);
            if (playerIndex !== -1) {
                const player = players[playerIndex];
                player.is_available = !player.is_available;
                savePlayers();
                showMessage(`Player ${player.name} is now ${player.is_available ? 'available' : 'unavailable'}`);
                renderPlayers();
            }
        }

        // Update court count function removed, only use custom courts

        // Add court
        function addCustomCourt() {
            const numberInput = document.getElementById('courtNumber');
            const number = numberInput.value.trim();

            if (!number) {
                showMessage('Please enter court number', 'error');
                return;
            }

            // Validate that input is a number
            const courtNum = parseInt(number);
            if (isNaN(courtNum) || courtNum < 1 || courtNum > 999) {
                showMessage('Court number must be a number between 1 and 999', 'error');
                return;
            }

            // Check if court with same number already exists
            if (courts.some(court => parseInt(court.number) === courtNum)) {
                showMessage('Court number already exists', 'error');
                return;
            }

            const newCourt = {
                id: nextCourtId++,
                number: courtNum.toString(),
                isOccupied: false,
                matchId: null
            };

            courts.push(newCourt);
            saveCourts();
            showMessage(`Court ${courtNum} added successfully`);
            numberInput.value = '';
            renderCourts();
        }

        // Delete court
        function deleteCustomCourt(courtId) {
            if (!confirm('Are you sure you want to delete this court?')) {
                return;
            }

            const courtIndex = courts.findIndex(court => court.id === courtId);
            if (courtIndex !== -1) {
                const court = courts[courtIndex];

                // Check if court is in use
                if (court.isOccupied) {
                    showMessage('Court is currently in use, cannot delete', 'error');
                    return;
                }

                courts.splice(courtIndex, 1);
                saveCourts();
                showMessage(`Court ${court.number} deleted`);
                renderCourts();
            }
        }

        // Render court status
        function renderCourts() {
            const container = document.getElementById('courtsContainer');

            if (courts.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; font-size: 1.1em;">No courts available. Please add courts first.</p>';
                return;
            }

            // Sort courts by number (ascending)
            const sortedCourts = [...courts].sort((a, b) => {
                const aNum = parseInt(a.number);
                const bNum = parseInt(b.number);
                return aNum - bNum;
            });

            container.innerHTML = sortedCourts.map(court => {
                const match = activeMatches.find(m => m.courtId === court.id);
                const isSelected = selectedCourt && selectedCourt.id === court.id;
                return `
                    <div class="court-card ${court.isOccupied ? 'occupied' : 'available'} ${isSelected ? 'selected' : ''}" onclick="selectCourt(${court.id})">
                        <button class="court-delete-btn" onclick="event.stopPropagation(); deleteCustomCourt(${court.id})" title="Delete Court">√ó</button>
                        <div class="court-number">Court ${court.number}</div>
                        <span class="court-status ${court.isOccupied ? 'court-occupied' : 'court-available'}">
                            ${court.isOccupied ? 'In Use' : 'Available'}
                        </span>
                        ${match ? `
                            <div class="match-info">
                                <strong>Match #${match.id}</strong><br>
                                ${match.players.map(p => p.name).join(' vs ')}
                                <button class="btn btn-warning" onclick="event.stopPropagation(); endSpecificMatch(${match.id})" style="margin-top: 10px; font-size: 0.8em;">
                                    üèÅ End Match
                                </button>
                            </div>
                        ` : `
                            <div style="margin-top: 10px; color: #666; font-size: 0.9em;">
                                Available - Use queue to assign matches
                            </div>
                        `}
                    </div>
                `;
            }).join('');
        }

        // Select court (disabled - use queue instead)
        function selectCourt(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (!court) return;

            if (court.isOccupied) {
                showMessage('This court is currently in use', 'error');
                return;
            }

            showMessage('Please use the Match Queue to assign matches to courts', 'error');
        }

        // Open player selection modal
        function openPlayerSelectionModal() {
            const modal = document.getElementById('playerSelectionModal');
            modal.classList.remove('hidden');

            if (editingQueueId === 'new') {
                // Creating new queue item
                document.getElementById('modalTitle').textContent = 'Add New Match to Queue';
                // selectedPlayers already set in addToQueue function
            } else if (editingQueueId) {
                // Editing existing queue item
                document.getElementById('modalTitle').textContent = `Edit Queue Match #${editingQueueId}`;
                // selectedPlayers already set in editQueueMatch function
            } else if (selectedCourt) {
                // Court assignment mode (disabled)
                document.getElementById('modalTitle').textContent = `Assign Players to Court ${selectedCourt.number}`;
                autoRandomSelectPlayers();
            }

            renderPlayerSelection();
            updateSelectedPlayersList();
        }

        // Close player selection modal
        function closePlayerSelectionModal() {
            const modal = document.getElementById('playerSelectionModal');
            modal.classList.add('hidden');
            selectedCourt = null;
            selectedPlayers = [];
            editingQueueId = null;
            renderCourts(); // Update court display to clear selection
        }



        // Render player selection interface
        function renderPlayerSelection() {
            const container = document.getElementById('playerSelectionGrid');

            if (players.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; grid-column: 1/-1;">No players found</p>';
                return;
            }

            container.innerHTML = players.map(player => {
                const cost = (player.cost || settings.baseCost) + (player.match_count * settings.matchCost); // Base cost + match cost per match
                const isSelected = selectedPlayers.some(p => p.id === player.id);
                const isUnavailable = !player.is_available;

                return `
                <div class="player-selection-item ${isSelected ? 'selected' : ''} ${isUnavailable ? 'unavailable' : ''}"
                     onclick="togglePlayerSelection(${player.id})">
                    <div style="font-weight: bold; font-size: 1em;">${player.name}</div>
                    <div style="font-size: 0.8em; color: #666;">Matches: ${player.match_count}</div>
                    <div style="font-size: 0.8em; color: #28a745; font-weight: bold;">‚Ç±${cost}</div>
                    ${isUnavailable ? '<div style="font-size: 0.7em; color: #dc3545; font-weight: bold;">UNAVAILABLE</div>' : ''}
                </div>
            `;}).join('');
        }

        // Toggle player selection status
        function togglePlayerSelection(playerId) {
            const playerIndex = selectedPlayers.findIndex(p => p.id === playerId);

            if (playerIndex !== -1) {
                // Deselect
                selectedPlayers.splice(playerIndex, 1);
            } else {
                // Select player
                if (selectedPlayers.length >= 4) {
                    showMessage('Maximum 4 players can be selected', 'error');
                    return;
                }

                const player = players.find(p => p.id === playerId);
                if (player) {
                    selectedPlayers.push(player);
                }
            }

            renderPlayerSelection();
            updateSelectedPlayersList();
        }

        // Update selected players list
        function updateSelectedPlayersList() {
            const container = document.getElementById('selectedPlayersList');
            const countSpan = document.getElementById('selectedCount');
            const saveBtn = document.getElementById('saveQueueBtn');

            countSpan.textContent = selectedPlayers.length;

            if (selectedPlayers.length === 0) {
                container.innerHTML = '<span style="color: #666;">Please select players</span>';
            } else {
                container.innerHTML = selectedPlayers.map(player =>
                    `<span class="selected-player-tag">${player.name}</span>`
                ).join('');
            }

            // Enable save button when exactly 4 players are selected (for queue editing)
            if (saveBtn) {
                saveBtn.disabled = selectedPlayers.length !== 4;
            }
        }

        // Auto randomly select 4 players (executed by default when modal opens)
        function autoRandomSelectPlayers() {
            const availablePlayers = players.filter(player => player.is_available);

            if (availablePlayers.length < 4) {
                // If less than 4 available players, clear selection without showing error (let user discover)
                selectedPlayers = [];
                return;
            }

            // Clear current selection
            selectedPlayers = [];

            // Randomly select 4 players
            const shuffled = [...availablePlayers].sort(() => 0.5 - Math.random());
            selectedPlayers = shuffled.slice(0, 4);
        }

        // Manually randomly select 4 players (executed when user clicks button)
        function randomSelectPlayers() {
            const availablePlayers = players.filter(player => player.is_available);

            if (availablePlayers.length < 4) {
                showMessage(`Insufficient available players. Need 4 players, only ${availablePlayers.length} available`, 'error');
                return;
            }

            // Clear current selection
            selectedPlayers = [];

            // Randomly select 4 players
            const shuffled = [...availablePlayers].sort(() => 0.5 - Math.random());
            selectedPlayers = shuffled.slice(0, 4);

            // Update interface
            renderPlayerSelection();
            updateSelectedPlayersList();
            showMessage('4 players randomly selected');
        }

        // Clear selected players
        function clearSelectedPlayers() {
            selectedPlayers = [];
            renderPlayerSelection();
            updateSelectedPlayersList();
            showMessage('Selection cleared');
        }

        // Start match for selected court
        function startMatchForCourt() {
            if (!selectedCourt) {
                showMessage('Please select a court first', 'error');
                return;
            }

            if (selectedPlayers.length === 0) {
                showMessage('Please select players or click "Random Select 4 Players"', 'error');
                return;
            }

            if (selectedPlayers.length < 4) {
                showMessage(`Insufficient players. Need 4 players, currently selected ${selectedPlayers.length}`, 'error');
                return;
            }

            if (selectedPlayers.length > 4) {
                showMessage(`Too many players. Maximum 4 players allowed, currently selected ${selectedPlayers.length}`, 'error');
                return;
            }

            // Create new match
            const newMatch = {
                id: nextMatchId++,
                courtId: selectedCourt.id,
                players: selectedPlayers.map(p => ({...p})),
                startTime: new Date().toLocaleString()
            };

            // Update court status
            selectedCourt.isOccupied = true;
            selectedCourt.matchId = newMatch.id;

            // Update selected players' status
            selectedPlayers.forEach(selectedPlayer => {
                const playerIndex = players.findIndex(player => player.id === selectedPlayer.id);
                if (playerIndex !== -1) {
                    players[playerIndex].is_available = false; // Unavailable during match
                }
            });

            activeMatches.push(newMatch);

            savePlayers();
            saveCourts();
            saveActiveMatches();

            showMessage(`Match started! Playing on Court ${selectedCourt.number}`);

            closePlayerSelectionModal();
            renderPlayers();
            renderCourts();
        }

        // Display match result
        function displayMatchResult(matchPlayers, courtNumber) {
            const resultDiv = document.getElementById('matchResult');

            resultDiv.innerHTML = `
                <div class="match-result">
                    <h3>üéâ Match Started</h3>
                    <p>Court: <strong>Court ${courtNumber}</strong></p>
                    <p>Players:</p>
                    <div class="match-players">
                        ${matchPlayers.map((player, index) => {
                            const cost = (player.cost || settings.baseCost) + (player.match_count * settings.matchCost);
                            return `
                            <div class="match-player">
                                <strong>${index + 1}. ${player.name}</strong><br>
                                <small>Current matches: ${player.match_count}</small><br>
                                <small style="color: #28a745; font-weight: bold;">Cost: ‚Ç±${cost}</small>
                            </div>
                        `;}).join('')}
                    </div>
                </div>
            `;

            resultDiv.classList.remove('hidden');
        }

        // Render active matches function removed as per requirement 26

        // End match functionality moved to individual buttons in court cards

        // End specific match
        function endSpecificMatch(matchId) {
            const matchIndex = activeMatches.findIndex(match => match.id === matchId);
            if (matchIndex === -1) {
                showMessage('Match does not exist', 'error');
                return;
            }

            const match = activeMatches[matchIndex];

            // Get court info for logging
            const court = courts.find(court => court.id === match.courtId);
            const courtNumber = court ? court.number : match.courtId;

            // Add to match log before removing
            addToMatchLog(match, courtNumber);

            // Update player match count and status
            match.players.forEach(matchPlayer => {
                const playerIndex = players.findIndex(player => player.id === matchPlayer.id);
                if (playerIndex !== -1) {
                    players[playerIndex].match_count += 1;
                    players[playerIndex].is_available = true; // Restore available status after match ends (requirement 20)
                }
            });

            // Release court
            if (court) {
                court.isOccupied = false;
                court.matchId = null;
            }

            // Remove match
            activeMatches.splice(matchIndex, 1);

            savePlayers();
            saveCourts();
            saveActiveMatches();

            showMessage(`Match #${match.id} ended, Court ${courtNumber} released`);
            renderPlayers();
            renderCourts();
        }

        // Reset player status and match counts (requirement 23)
        function resetPlayers() {
            if (!confirm('Are you sure you want to reset all player statuses and match counts?')) {
                return;
            }

            players.forEach(player => {
                player.is_available = true;
                player.match_count = 0; // Reset match count as well
                player.cost = settings.baseCost; // Reset cost to base amount
            });

            savePlayers();
            showMessage('All player statuses and match counts reset');
            renderPlayers();
        }

        // Load match log
        function loadMatchLog() {
            const savedLog = localStorage.getItem('badmintonMatchLog');
            if (savedLog) {
                matchLog = JSON.parse(savedLog);
            }
            renderMatchLog();
        }

        // Save match log
        function saveMatchLog() {
            localStorage.setItem('badmintonMatchLog', JSON.stringify(matchLog));
        }

        // Add match to log
        function addToMatchLog(match, courtNumber) {
            const logEntry = {
                id: match.id,
                courtNumber: courtNumber,
                players: match.players.map(p => p.name),
                startTime: match.startTime,
                endTime: new Date().toLocaleString()
            };
            matchLog.unshift(logEntry); // Add to beginning of array
            saveMatchLog();
            renderMatchLog();
        }

        // Clear match log
        function clearMatchLog() {
            if (!confirm('Are you sure you want to clear the match log?')) {
                return;
            }
            matchLog = [];
            saveMatchLog();
            renderMatchLog();
            showMessage('Match log cleared');
        }

        // Render match log
        function renderMatchLog() {
            const container = document.getElementById('matchLogContainer');

            if (matchLog.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; margin-top: 20px; font-size: 0.9em;">No match history available</p>';
                return;
            }

            // Compact format for floating window
            container.innerHTML = matchLog.map(entry => `
                <div style="background: white; border-radius: 6px; padding: 8px; margin-bottom: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); border-left: 3px solid #4facfe;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <span style="font-weight: bold; color: #4facfe; font-size: 0.8em;">Match #${entry.id}</span>
                        <span style="font-size: 0.7em; color: #666;">Court ${entry.courtNumber}</span>
                    </div>
                    <div style="margin-bottom: 3px; color: #333;">
                        <span style="font-size: 1.1em; font-weight: bold; color: #333;">${entry.players.join(', ')}</span>
                    </div>
                    <div style="font-size: 0.65em; color: #666; line-height: 1.1;">
                        <span><strong>Start:</strong> ${entry.startTime}</span> |
                        <span><strong>End:</strong> ${entry.endTime}</span>
                    </div>
                </div>
            `).join('');
        }

        // Update player statistics
        function updatePlayerStats() {
            const total = players.length;
            const available = players.filter(p => p.is_available).length;
            const unavailable = total - available;

            document.getElementById('totalPlayers').textContent = total;
            document.getElementById('availablePlayers').textContent = available;
            document.getElementById('unavailablePlayers').textContent = unavailable;
        }

        // Search players
        function searchPlayers() {
            searchTerm = document.getElementById('playerSearch').value;
            currentPage = 1; // Reset to first page
            renderPlayers();
        }

        // Toggle view mode
        function togglePlayerView() {
            isListView = !isListView;
            const btn = document.getElementById('viewToggleBtn');
            btn.textContent = isListView ? 'üî≤ Switch to Card View' : 'üìã Switch to List View';
            currentPage = 1; // Reset to first page
            renderPlayers();
        }

        // Update pagination controls
        function updatePagination(totalPages) {
            const pagination = document.getElementById('playerPagination');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');

            if (totalPages <= 1) {
                pagination.style.display = 'none';
                return;
            }

            pagination.style.display = 'block';
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            prevBtn.disabled = currentPage <= 1;
            nextBtn.disabled = currentPage >= totalPages;
        }

        // Change page
        function changePage(direction) {
            const totalPages = Math.ceil(filteredPlayers.length / playersPerPage);
            const newPage = currentPage + direction;

            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                renderPlayers();
            }
        }

        // Enter key to add player
        document.getElementById('playerName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addPlayer();
            }
        });

        // Enter key to add court
        document.getElementById('courtNumber').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCustomCourt();
            }
        });
    </script>
</body>
</html>
